\usepackage{listings}
\usepackage{textcomp}
\usepackage{fancyvrb}

\title{Boring Object Orientation}
\subtitle{Boring is better than interesting}
\author{Moshe Zadka -- https://cobordism.com}
\date{PyBay 2019}

\begin{document}
\begin{titlepage}
\maketitle
\end{titlepage}

\frame{\titlepage}

\begin{frame}[fragile]
\frametitle{Python and object oriented programming}

Everything is an object
\end{frame}

\begin{frame}[fragile]
\frametitle{Why OO design principles?}

Guidelines to code that is easy to maintain
\end{frame}

\begin{frame}[fragile]
\frametitle{Do OO design principles work?}

Yes
\pause
...but
\end{frame}

\begin{frame}[fragile]
\frametitle{Why declare interfaces?}

Explicit is better than implicit
\end{frame}

\begin{frame}[fragile]
\frametitle{Declaring interfaces with zope.interface}

\begin{lstlisting}
from zope import interface

class ISprite(interface.Interface):

    bounding_box = interface.Attribute(
        "The bounding box"
    )

    def intersects(self, box):
        "Does this intersect with a box"
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Testing for interface provision}

\begin{lstlisting}
from zope.interface import verify

def test_implementation():
    sprite = make_sprite()
    verify.verifyObject(ISprit, sprite)
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Interesting constructor}

\begin{lstlisting}
class Stuff:

    def __init__(self, fname):
        # Create a new object
        self.destination = Destination()
        # Call a system call
        self.finput = open(fname)
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Boring constructor}

\begin{lstlisting}
class Stuff:

    def __init__(self, finput, destination):
        self.destination = destination
        self.finput = finput

    @classmethod
    def from_name(cls, name):
        # Create a new object
        destination = Destination()
        # Call a system call
        finput = open(fname)
        return cls(finput, destination)
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]
\frametitle{Why boring constructors}

\begin{itemize}
\item No partial objects
\item Easier testing
\end{itemize}

\end{frame}

\begin{frame}[fragile]
\frametitle{Using attrs}

\begin{lstlisting}
import attr

@attr.s(auto_attribs=True)
class Stuff:
    finput: Any
    destination: Any
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Immutable objects}

\begin{lstlisting}
>>> @attr.s(auto_attribs=True, frozen=True)
... class Stuff:
...     destination: Any
...     finput: Any
... 
>>> my_stuff = Stuff(Destination(), io.StringIO())
>>> my_stuff.finput = io.StringIO()
Traceback (most recent call last):
...
    raise FrozenInstanceError()
attr.exceptions.FrozenInstanceError
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Immutablity as bug avoidance}

\begin{lstlisting}
def some_function(some_list=[]):
    pass
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Immutablity as interface simplifying}

No variation, no invariant breakage!
\end{frame}

\begin{frame}[fragile]
\frametitle{Frozen attrs}

\begin{lstlisting}
>>> @attr.s(auto_attribs=True, frozen=True)
... class Point:
...     x: float
...     y: float
... 
>>> origin = Point(0, 0)
>>> up = attr.evolve(origin, y=1)
>>> origin, up
(Point(x=0, y=0), Point(x=0, y=1))
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Private methods}

\begin{lstlisting}
class HTTPSession:
    def _request(self, method, url):
        pass
    def get(self, url):
        return self._request('GET', url)
    def head(self, url):
        return self._request('HEAD', url)
\end{lstlisting}
    
\end{frame}

\begin{frame}[fragile]
\frametitle{Refactoring private methods away}

\begin{lstlisting}
class RawHTTPSession:
    def request(self, method, url):
        pass
class HTTPSession:
    _raw: RawHTTPSession
    def get(self, url):
        return self._raw.request('GET', url)
    def head(self, url):
        return self._raw.request('HEAD', url)
\end{lstlisting}
    
\end{frame}

\begin{frame}[fragile]
\frametitle{Methods}

\begin{lstlisting}
@attr.s(auto_attribs=True, frozen=True)
class Point2D:
    x: float
    y: float

    def distance_from_origin(self):
        return (self.x**2 + self.y**2) ** 0.5

@attr.s(auto_attribs=True, frozen=True)
class Point3D:
    x: float
    y: float
    z: float

    def distance_from_origin(self):
        return (self.x**2 + self.y**2 + self.z**2) ** 0.5
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Why not methods?}

Bloats classes

\end{frame}

\begin{frame}[fragile]
\frametitle{singledispatch example}

\begin{lstlisting}
@attr.s(auto_attribs=True, frozen=True)
class Point2D:
    x: float
    y: float

@attr.s(auto_attribs=True, frozen=True)
class Point3D:
    x: float
    y: float
    z: float

@functools.singledispatch
def distance_from_origin(thing):
    raise NotImplementedError(thing)

@distance_from_origin.register(Point2D)
def distance_2d(thing):
    return (thing.x**2 + thing.y**2) ** 0.5

@distance_from_origin.register(Point3D)
def distance_3d(thing):
    return (thing.x**2 + thing.y**2 + thing.z**2) ** 0.5
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]
\frametitle{Inheritance-as-API: Examples in the wild}

\begin{itemize}
\item Twisted \pause
\item Django \pause
\item Jupyter
\end{itemize}

\end{frame}

\begin{frame}[fragile]
\frametitle{Inheritance-as-API: Issues}

"Shared everything"
\end{frame}

\begin{frame}[fragile]
\frametitle{Composition}

\begin{itemize}
\item Define *interface*
\item Useful behavior in *referred class*
\end{itemize}

\end{frame}

\begin{frame}[fragile]
\frametitle{Composition example}
Sans-IO
\end{frame}

\begin{frame}[fragile]
\frametitle{Composition: Simple example}
\begin{lstlisting}
class IMovable(interface.Interface):
    x_position = interface.Attribute()
    y_position = interface.Attribute()
    def tick():
        pass

@interface.implementer(IMovable)
@attr.s(auto_attribs=True):
class StraightLine:
    dx: float
    dy: float
    x_position: float
    y_position: float
    def tick(self):
        self.x_position += dx
        self.y_position += dy

@interface.implementer(IMovable)
@attr.s(auto_attribs=True):
class Sprite:
     _movable: IMovable
     @property
     def x_position(self): return self._movable.x_position
     @property
     def y_position(self): return self._movable.y_position
     def tick(self): return self._movable.tick()
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Python: Language of the free}

Diamond inheritance with overriddable constructors as mandatory interface?
Sure!
\end{frame}

\begin{frame}[fragile]
\frametitle{With Great Power}

Diamond inheritance with overriddable constructors as mandatory interface?
....Maybe not!
\end{frame}

\begin{frame}[fragile]
\frametitle{Lessons Learned}

Big systems, big headaches
\end{frame}

\begin{frame}[fragile]
\frametitle{Less interesting code}

Be dumb as possible when writing code.

\end{frame}

\end{document}
